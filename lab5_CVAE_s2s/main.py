from __future__ import unicode_literals, print_function, division
from io import open
import unicodedata
import string
import re
import random
import time
import math
import torch
import torch.nn as nn
from torch import optim
import torch.nn.functional as F
import matplotlib.pyplot as plt
plt.switch_backend('agg')
import matplotlib.ticker as ticker
import numpy as np
from os import system
from nltk.translate.bleu_score import SmoothingFunction, sentence_bleu
from dataloader import WordDataset, WordTransoformer
from torch.utils.data import DataLoader
from cvae import CVAE
from torch.utils.tensorboard import SummaryWriter
import time
import sys
import argparse

"""========================================================================================
The sample.py includes the following template functions:

1. Encoder, decoder
2. Training function
3. BLEU-4 score function
4. Gaussian score function

You have to modify them to complete the lab.
In addition, there are still other functions that you have to 
implement by yourself.

1. The reparameterization trick
2. Your own dataloader (design in your own way, not necessary Pytorch Dataloader)
3. Output your results (BLEU-4 score, conversion words, Gaussian score, generation words)
4. Plot loss/score
5. Load/save weights

There are some useful tips listed in the lab assignment.
You should check them before starting your lab.
========================================================================================"""

parser = argparse.ArgumentParser(description='s2s CVAE model')
parser.add_argument('--epoch', type=int)
parser.add_argument('--load_model', type=str)
parser.add_argument('--exp_name', type=str, default='')
# annealing paramters
parser.add_argument('--warmup', type=int, default=5)
parser.add_argument('--kl_start', type=float, default=0)
parser.add_argument('--annealing', type=str, default='mono')
args = parser.parse_args()

device = torch.device("cuda" if torch.cuda.is_available() else "cpu")
#----------Hyper Parameters----------#
lr = 0.05
if args.epoch != None:
    epochs = args.epoch
else:    
    epochs = 150
latent_size = 32
cycle = 10
kl_weight = args.kl_start

################################
#Example inputs of compute_bleu
################################
#The target word
reference = 'accessed'
#The word generated by your model
output = 'access'

#compute BLEU-4 score
def compute_bleu(output, reference):
    cc = SmoothingFunction()
    if len(reference) == 3:
        weights = (0.33,0.33,0.33)
    else:
        weights = (0.25,0.25,0.25,0.25)
    return sentence_bleu([reference], output,weights=weights,smoothing_function=cc.method1)


"""============================================================================
example input of Gaussian_score

words = [['consult', 'consults', 'consulting', 'consulted'],
['plead', 'pleads', 'pleading', 'pleaded'],
['explain', 'explains', 'explaining', 'explained'],
['amuse', 'amuses', 'amusing', 'amused'], ....]

the order should be : simple present, third person, present progressive, past
============================================================================"""

def Gaussian_score(words):
    words_list = []
    score = 0
    yourpath = 'dataset/train.txt'#should be your directory of train.txt
    with open(yourpath,'r') as fp:
        for line in fp:
            word = line.split(' ')
            word[3] = word[3].strip('\n')
            words_list.extend([word])
        for t in words:
            for i in words_list:
                if t == i:
                    score += 1
    return score/len(words)


def asMinutes(s):
    m = math.floor(s / 60)
    s -= m * 60
    return '%dm %ds' % (m, s)


def timeSince(since, percent):
    now = time.time()
    s = now - since
    es = s / (percent)
    rs = es - s
    return '%s (- %s)' % (asMinutes(s), asMinutes(rs))

def criterion(predict_distribution, target_distribution, mu, logvar, predict_length):
    cross_entropy = nn.CrossEntropyLoss()
    reconstruction_loss = cross_entropy(predict_distribution[:predict_length], target_distribution[:predict_length])

    # KL(N(mu, logvar)||N(0,1))
    # multivariate Gaussian kl
    kl_loss = -0.5 * torch.sum(1 + logvar - mu**2 - logvar.exp())

    return reconstruction_loss, kl_loss

def train(model, dataloader, optimizer, transformer, kl_weight):
    total_BLEU_score = 0
    total_rc_loss = 0
    total_kl_loss = 0
    model.train()
    for times, (word_tensor, tense_tensor) in enumerate(dataloader):
        optimizer.zero_grad()
        word_tensor = word_tensor[0]
        tense_tensor = tense_tensor[0]
        word_tensor, tense_tensor = word_tensor.to(device), tense_tensor.to(device)
        output, predict_distribution, mean, log_var = model(word_tensor, tense_tensor, teacher_forcing_ratio)
        reconstruction_loss, kl_loss = criterion(predict_distribution, word_tensor.view(-1), mean, log_var, len(output))
        # if kl_weight >= 1:
        #     kl_weight = 1
        # else:
        #     kl_weight += times * annealing_rate
        
        loss = reconstruction_loss + kl_weight * kl_loss
        total_rc_loss += reconstruction_loss.item()
        total_kl_loss += kl_loss.item()
        loss.backward()
        optimizer.step()

    return total_rc_loss, total_kl_loss

def evaluate(model, dataloader, tense_list):
    with torch.no_grad():
        model.eval()
        total_BLEU_score = 0
        predict_list = []
        for times, (word_tensor, tense_tensor, target) in enumerate(dataloader):
            word_tensor = word_tensor[0]
            tense_tensor = tense_tensor[0]
            target = target[0]
            word_tensor, tense_tensor = word_tensor.to(device), tense_tensor.to(device)
            # inference without teacher forcing => teacher forcing ratio sets -1
            output, predict_distribution, mean, log_var = model(word_tensor, tense_tensor, -1)

            predict = transformer.tensor2words(output)
            total_BLEU_score += compute_bleu(predict, target)
            
            predict_list.append(predict)
        
        # Gaussian score
        words = []
        for i in range(100):
            latent = torch.randn(1, 1, latent_size).to(device)
            words.append(model.generate_words(latent, tense_list))
        for word_list in words:
            for i in range(len(word_list)):
                word_list[i] = transformer.tensor2words(word_list[i])
        gaussian_score = Gaussian_score(words)
      
    return total_BLEU_score/len(dataloader.dataset), predict_list, gaussian_score, words

def record_score(bleu_score, gaussian_score, predict_list, generate_words, dataloader, transformer):
    bleu_record = open('bleu_record.txt', 'w')
    for i, (word_tensor, tense_tensor, target) in enumerate(dataloader):
        word_tensor = word_tensor[0]
        target = target[0]
        input_word = transformer.tensor2words(word_tensor)
        print('----------------', file=bleu_record)
        print('Input: ', input_word, file=bleu_record)
        print('Target: ', target, file=bleu_record)
        print('Prediction: ', predict_list[i], file=bleu_record) 
        print('----------------\n', file=bleu_record)

    print('Average BLEU-4 score: ', bleu_score, file=bleu_record)
    bleu_record.close()
    
    gaussian_record = open('gaussian_record.txt', 'w')
    for word_list in generate_words:
        for i, word in enumerate(word_list):
            if (i+1) % 4 != 0:
                word += ', '
            else:
                word +='\n'
            print(word, file=gaussian_record, end='')
    print('Gaussian score: ', gaussian_score, file=gaussian_record)
    gaussian_record.close()

# def get_kl_weight(epoch):
#     epoch += 1
#     slope = 0.01
#     scope = (1.0/slope)*2
#     weight = (epoch % scope) * slope
#     if weight > 1:
#         weight = 1
#     return weight

def getTeacherRatio(epoch):
    # from 1 to 0
    # return 0.5
    return 1.-(1./(epochs-1))*(epoch)

def sigmoid(x):
    return 1 / (1 + np.exp(-x))

def get_kl_weight(epoch,epochs,kl_annealing_type,time):
    """
    :param epoch: i-th epoch
    :param kl_annealing_type: 'monotonic' or 'cycle'
    :param time:
        if('monotonic'): # of epoch for kl_weight from 0.0 to reach 1.0
        if('cycle'):     # of cycle
    """
    assert kl_annealing_type=='monotonic' or kl_annealing_type=='cycle','kl_annealing_type not exist!'

    if kl_annealing_type == 'monotonic':
        return (1./(time-1))*(epoch-1) if epoch<time else 1.

    else: #cycle
        period = epochs//time
        epoch %= period
        kl_weight = sigmoid((epoch - period // 2) / (period // 10)) / 2

        # if epoch % time == 0:
        #     kl_weight = args.kl_start
        # else:
        #     kl_weight = min(1, (epoch%time) * 0.015)

        return kl_weight

if __name__ == '__main__':
    train_dataset = WordDataset('train')
    test_dataset = WordDataset('test')
    max_length = train_dataset.max_length
    train_dataloader = DataLoader(train_dataset, batch_size=1, shuffle=True)
    test_dataloader = DataLoader(test_dataset, batch_size=1, shuffle=True)
    tense_list = test_dataloader.dataset.tense2idx.values()
    
    model = CVAE(max_length)
    model = model.to(device)
    if args.load_model != None:
        state_dict = torch.load(args.loadmodel)
        model.load_state_dict(state_dict)
    optimizer = optim.SGD(model.parameters(), lr=lr)
    transformer = WordTransoformer()
    trainset_size = len(train_dataloader.dataset)
    testset_size = len(test_dataloader.dataset)
    writer = SummaryWriter('logs/' + args.exp_name)
    
    start = time.time()
    best_bleu_score = 0
    annealing_rate = 0.01
    cycle = 15
    # annealing_rate = 1./(args.warmup * len(train_dataloader.dataset))
    print('Annealing: ', args.annealing)
    for epoch in range(epochs):
        # if args.annealing == 'cyclical' and epoch % cycle == 0:
        #     kl_weight = args.kl_start
        kl_weight = get_kl_weight(epoch+1, epochs, 'cycle', 2)
        # kl_weight = 0
        teacher_forcing_ratio = getTeacherRatio(epoch)
        rc_loss, kl_loss = train(model, train_dataloader, optimizer, transformer, kl_weight)
        average_bleu_score, predict_list, gaussian_score, generate_words = evaluate(model, test_dataloader, tense_list)
        writer.add_scalar('Loss/reconstruction loss', rc_loss/trainset_size, epoch+1)
        writer.add_scalar('Loss/KL loss', kl_loss/trainset_size, epoch+1)
        writer.add_scalar('BLEU-4 score', average_bleu_score, epoch+1)
        writer.add_scalar('Setting parameter/KL weight', kl_weight, epoch+1)
        writer.add_scalar('Setting parameter/teacher forcing ratio', teacher_forcing_ratio, epoch+1)
        writer.add_scalars('Comparison', {'rc_loss': rc_loss/trainset_size, 
                                          'kl_loss': kl_loss/trainset_size, 
                                          'BLEU-4 socre': average_bleu_score,
                                          'kl_weight': kl_weight,
                                          'teacher_ratio': teacher_forcing_ratio,
                                          'gaussian_score': gaussian_score}, epoch+1)
        print('Epoch ', epoch+1)
        print('Average Reconstruction loss: %f\n Average KL loss: %f' % (rc_loss/trainset_size, kl_loss/trainset_size))
        print('Average BLEU-4 score: %f\n' % average_bleu_score)
        
        if average_bleu_score > best_bleu_score:
            record_score(average_bleu_score, gaussian_score, predict_list, generate_words, test_dataloader, transformer)
            best_bleu_score = average_bleu_score

        torch.save(model.state_dict(), 'model/checkpoint' + str(epoch) + '.pkl')
    end = time.time()
    print('Total training time: ' + str((end - start)//60) + ' minutess')